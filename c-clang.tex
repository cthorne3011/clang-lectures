\documentclass[landscape]{beamer}

\usepackage{drawstack}

\title{Functions and stack frames
\\[1em]
\(
 C \stackrel{\mbox{Clang}}{\longrightarrow} x86
 \)
 }
\author{Hayo Thielecke
\\
University of Birmingham
\\
\url{http://www.cs.bham.ac.uk/~hxt}
}


\begin{document}

\begin{frame}{}
\maketitle
\end{frame}

\begin{frame}{Contents}
\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{Structure of the module}

\begin{block}{Parsing \checkmark}
\begin{itemize}
\item Progression from: Language + Logic, Models of Computation
\item abstract machines, formal,``mathy''
\end{itemize}
\end{block}

\begin{block}{C and call stack}
\begin{itemize}
\item Progression from: Computer Systems + Architecture, C/C++
\item not so formal, by example, x86 machine code
\end{itemize}
\end{block}

\begin{block}{Implementing functional languages}
\begin{itemize}
\item Progression from: functional programming
\item builds on abstract machines and C stack
\end{itemize}
\end{block}

\end{frame}

\begin{frame}{Aims and overview}

\begin{itemize}
\item
We will see some typical C code compiled to x86 assembly by LLVM
\item Emphasise general principles used in almost all compilers
\item Use LLVM on C and x86 for example and concreteness
\item
\alert{What} LLVM does, not details of \alert{how} it does it internally
\item
Enough to compile some C code by hand line by line
\item
C language features $\mapsto$ soup of mainly mov instructions
\item
Various language features on top of vanilla functions
\item
Optimizations

\end{itemize}

\end{frame}


\begin{frame}{Clang and LLVM, the bestest and mostest}

Clang C/C++ compiler

\url{http://clang.llvm.org}

Compiler Infrastructure

\url{http://llvm.org}

\url{http://www.aosabook.org/en/llvm.html}

Apple 
\url{https://developer.apple.com/xcode/}

Many projects, for example:

Emscripten: An LLVM to JavaScript Compiler

Rust: a safe, concurrent, practical language

\end{frame}

\begin{frame}{Two big ideas in compiling functions}

\begin{block}{stack $\leftrightarrow$ recursion}

compare: parsing stack

many abstract and not so abstract machines use stacks

including JVM

In C: one stack frame per function call
\end{block}

\begin{block}{Names $\to$ indices}
Names can be compiled into indices, discovered many times

%deBruijn indices: lambda calculus without variables
%
%cartesian closed categories, CAM machine for CAML

In C: variables become small integers to be added to the base pointer

\end{block}

\end{frame}


\begin{frame}[fragile]{Call stack: used by C at run time for function calls}

%On most hardware, the stack grows towards smaller addresses.

Convention: we draw the stack growing \alert{downwards} on the page. 

Suppose function \texttt g calls function \texttt f.


\begin{tikzpicture}[scale=.8]
  \stacktop{}
  \startframe
      \cell{}  
\cellcom{parameters for \texttt g} 
    \cell{}  
\cellcom{return address for \texttt g} 
      \cell{}        
    \cellcom{automatic variables in g}         
\finishframe{frame for \texttt g\ } 
  \startframe
  \cell{}  
    \cellcom{parameters for f} 
  \cell{}  
\cellcom{return address  for \texttt f} 
  \cell{}  
    \cellcom{automatic variables in f}
 \finishframe{frame for \texttt f\ } 
\end{tikzpicture}
There may be more in the frame, e.g. saved registers  
\end{frame}   


\begin{frame}[fragile]{Call stack: one frame per function \alert{call}}

%On most hardware, the stack grows towards smaller addresses.

Recursion example: fac(n) calls fac(n - 1) 
\\[2em]

\begin{tikzpicture}[scale=.8]
  \stacktop{}
    \startframe
      \cell{2}  
    \cellcom{argument}
  \cell{return address}  
  \finishframe{frame for {fac(2)}} 
  \startframe
      \cell{1}  
    \cellcom{argument}
  \cell{return address}  
  \finishframe{frame for {fac(1)}} 
  \startframe
  \cell{0}  
    \cellcom{argument} 
  \cell{return address}  
 \finishframe{frame for fac(0)} 
\end{tikzpicture}

\end{frame}   


\section{Target architecture}

\begin{frame}{Target architecture}

We will only need a tiny subset of assembly.

Quite readable.

Instruction we will need:

mov push pop call ret jmp add mul test be

The call instruction pushes the current instruction pointer onto the stack as the return address

ret pops the return address from the stack and makes it the new instruction pointer

A nice target architecture should have lots of general-purpose registers with indexed addressing.

Like RISC, but x86 is getting there in the 64-bit architecture

\end{frame}

\begin{frame}{x86 in AT\&T syntax}

mov syntax is target last

\texttt{mov} x y is like y = x ;

Assembly generated by clang version 3.3

r prefix on registers means 64 bit register

movq etc: q suffix means quadword = 64 bits

\texttt{\%} register

\texttt{\$} constant

indexed addressing \texttt{-24(\%rbp)}

\end{frame}


\begin{frame}[fragile]{Clang function idiom}

\url{http://llvm.org/docs/LangRef.html#calling-conventions}

\begin{verbatim}
f:
	pushq	%rbp
	movq	%rsp, %rbp
    ... body of function f
	popq	%rbp
	ret
\end{verbatim}

parameters are passed in registers rdi, rsi

return value is passed in register rax
\end{frame}


\begin{frame}[fragile]{Stack frame in clang C calling convention on x86}
The stack grows down on the page

lower addresses are lower on the page

\begin{tikzpicture}[scale=.6]
  \startframe
     \cell{return addr} 
    \cell{old bp}  \cellptr{\textrm{frame/base pointer}} 
      \cell{parameter n}
     \cell[padding]{\vdots}
         \cell{parameter 1} %\cellptr{\texttt{stack} + 2}
    \cell{local var}
     \cell[padding]{\vdots}
    \cell{local var}\cellptr{\textrm{stack pointer, if used}} 
%\finishframe{array} 
\end{tikzpicture}
  
\end{frame} 


\begin{frame}[fragile]{Clang stack frame example}
The stack grows down on the page

lower addresses are lower on the page

parameters are passed in registers, may be saved into frame if needed

\begin{tikzpicture}[scale=.6]
 % \startframe
     \cell{return addr} 
    \cell{old bp}  \cellptr{\textrm{base pointer}} 
      \cell{y}\cellptr{\textrm{bp - 8}}
         \cell{x} \cellptr{\textrm{bp - 16}}
    \cell{a}  \cellptr{\textrm{bp - 24}}
    \cell{b} \cellptr{\textrm{bp - 32}}
% \finishframe{array} 
\end{tikzpicture}
  
\end{frame} 


\begin{frame}[fragile]{Compiled with clang -S}
\begin{minipage}{.5\textwidth}
\begin{verbatim}
long f(long x, long y)
{
  long a, b;
  a = x + 42;
  b = y + 23;
  return a * b;
}
\end{verbatim}

y$\mapsto$ rbp-8

x$\mapsto$ rbp-16

a$\mapsto$ rbp-24

b$\mapsto$ rbp-32

\end{minipage}
%
\begin{minipage}{.4\textwidth}
\begin{verbatim}
f:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	%rdi, -8(%rbp)
	movq	%rsi, -16(%rbp)
	movq	-8(%rbp), %rsi
	addq	$42, %rsi
	movq	%rsi, -24(%rbp)
	movq	-16(%rbp), %rsi
	addq	$23, %rsi
	movq	%rsi, -32(%rbp)
	movq	-24(%rbp), %rsi
	imulq	-32(%rbp), %rsi
	movq	%rsi, %rax
	popq	%rbp
	ret
\end{verbatim}
\end{minipage}
\end{frame}


\begin{frame}[fragile]{Compiled with clang -S -O3}
\begin{minipage}{.5\textwidth}
\begin{verbatim}
long f(long x, long y)
{
  long a, b;
  a = x + 42;
  b = y + 23;
  return a * b;
}
\end{verbatim}
\end{minipage}
%
\begin{minipage}{.4\textwidth}
\begin{verbatim}
f:                                      
	addq	$42, %rdi
	leaq	23(%rsi), %rax
	imulq	%rdi, %rax
	ret
\end{verbatim}
\end{minipage}
\end{frame}


\begin{frame}[fragile]{Many arguments}
Some passed on the stack, not in registers. These have positive indices. Why?
\\[2em]

\begin{minipage}{.6\textwidth}
\begin{verbatim}
long a(long x1, long x2, 
long x3, long x4, long x5, 
long x6, long x7, long x8)
{
  return x1 + x7 + x8;
}
\end{verbatim}
\end{minipage}
%
\begin{minipage}{.3\textwidth}
\begin{verbatim}
a:                             
	addq	8(%rsp), %rdi
	addq	16(%rsp), %rdi
	movq	%rdi, %rax
	ret
\end{verbatim}
\end{minipage}
\end{frame}


\end{document}

